= Team 5
:toc-title: Inhaltsverzeichnis
:toclevels: 4
:toc:
:author: Tiantcheu Larissa <s0561829@htw-berlin.de>
:author: Ostrzinski Christoph <s0568880@htw-berlin.de>
:author: Matthias Kronenberg <s0571096@htw-berlin.de>

== Lecture Sheet 3

=== Matzes Part

=== Christophs Part

== Lecture Sheet 2

=== Vor- und Nachteile von Docker

Mit Docker wir Flask automatisch installiert.
Das Betriebssystem im Hintergrund ist bei allen Teammitgliedern das gleiche.
Dadurch können beispielsweise keine Probleme durch Betriebssystemspezifische Pfadangaben enstehen.

=== Setup ohne Docker

An unserem Setup hätte sich ohne Docker bisher nichts geändert.

=== Dokumentation

Wir haben 4 HTTP Endpoints in Flask festgelegt.

Da Flask zustandlos ist, muss bei jedem weiteren Aufrufen eines Endpoints die JSON Datei erneut eingelesen werden.
Mithilfe der JSON Testdaten versuchen wir jedem Kunden ein Auto zuzuordnen, solange es noch nicht vergeben ist.

==== /customers & /cars

Mit den Endpoints "/customer" und "/cars" werden alle im System vorhandenen Kunden und Autos ausgegeben.
Dazu mussten wir die Liste mit dem __dict__ Attribut aufrufen und mit einer Schleife durchlaufen.
Der Output wurde dann per jsonify geparst und ausgegeben.

==== /customer/<first_name>/<last_name>/book/<car_id>

Beim Endpoint /customer/<first_name>/<last_name>/book/<car_id> nehmen wir die car_id und gehen alle 5 Autonamen durch und versuchen, das passende Auto zu finden.
Das Auto wird, falls es nicht bereits gebucht ist, auf den angegebene Namen gebucht.

==== /customer/<first_name>/<last_name>/history

Beim Endpoint /customer/<first_name>/<last_name>/history durchlaufen wir die customers in unseren JSON Testdaten und geben dann per jsonify die passende Buchungshistorie aus.

....

{
  "data": {
    "cars": [
      {
        "name": "Kaefer",
        "number_of_seats": 4,
        "color": "yellow",
        "brand": "VW",
        "is_booked": false
      },
      {
        "name": "991",
        "number_of_seats": 4,
        "color": "red",
        "brand": "Porsche",
        "is_booked": false
      },
      {
        "name": "AMG",
        "number_of_seats": 5,
        "color": "white",
        "brand": "Mercedes",
        "is_booked": false
      },
      {
        "name": "Q7",
        "number_of_seats": 5,
        "color": "black",
        "brand": "AUDI",
        "is_booked": false
      },
      {
        "name": "i7",
        "number_of_seats": 2,
        "color": "blue",
        "brand": "BMW",
        "is_booked": false
      }
    ]
  },
  "customers": [
    {
      "first_name": "Larissa",
      "last_name": "Tiantcheu"
    },
    {
      "first_name": "Christoph",
      "last_name": "Ostrzinski"
    },
    {
      "first_name": "Matthias",
      "last_name": "Kronenberg"
    }
  ]
}
....

== Lecture Sheet 1

=== Aufgabe 1 - List of requirements

* 4 Gruppen angelegt Car, Customer, Booking, BookingList
* Car: name, color, number_of_seats, brand
* Customer: first_name, last_name
* Booking: car, customer, start, end
* BookingList: bookings <- muss checken, ob car bereits gebucht (bisher nur anhand des Namens)

=== Aufgabe 2 - Coding

* Pro Gruppe aus den Requirements haben wir eine Classe und die dazugehörigen Attribute angelegt
* Ein grundlegende Projektstruktur wurde erstellt
* Für jede Klasse wurde eine "to_json"-Methode implementiert um das spätere Interagieren mit dem Server zu erleichtern

=== Aufgabe 3 - Testdata

* In einer gesonderten Datei (.car-data.json) haben wir Testdaten hinterlegt.
* Über die Main Methode haben wir die Daten eingelesen.
** Als erstes werden gemäß der Testdaten-Datei die Car-Objekte erzeugt.
** Als zweites werden gemäß der Testdaten-Datei die Customer-Objekte erzeugt.
** Jedem Customer wird ein zufälliges Auto zugewiesen.
*** dies geschieht über das Erstellen eines Booking-Objektes
** Anschließend wird das Booking-Objekt der Liste hinzugefügt
*** dabei wird überprüft, ob das Auto bereits vermietet wurde
* Ein Test, ob das Doppelte Vermieten eines Autos möglich ist, wurde hinzugefügt